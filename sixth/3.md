# 继承

## 原型链

```javascript
function SuperType() {
  this.property = true;
}
SuperType.prototype.getSuperValue = function() {
  return this.property;
};
function SubType() {
  this.subproperty = false;
}
SubType.prototype = new SuperType();
Subtype.prototype.getSubValue = function() {
  return this.subproperty;
};
var instance = new SubType();
alert(instance.getSuperValue());//true
```

在上面的代码中，没有使用SubType提供的默认原型，而是添加了一个新原型。新原型不仅拥有作为一个SuperType的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向SuperType原型



在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样会重写原型链

```javascript
function SuperType() {
  this.property = true;
}
SuperType.prototype.getSuperValue = function() {
  return this.property;
};
function SubType() {
  this.subproperty = false;
}
//继承了SuperType
SubType.prototype = new SuperType();
//字面量添加新方法
SubType.prototype = {
  getSubvalue: function() {
    return this.subproperty;
  },
  someOtherMethod: function () {
    return false;
  }
};
var instance = new SubType();
alert(instance.getSuperValue());
```

##### 原型链的问题

引用类型的原型会被所有实例共享

```javascript
function SuperType() {
  this.colors = ['1','2','3'];
}
function SubType() {
}
//继承了SuperType
SubType.prototype = new SuperType();
var instance1 = new SubType();
instance1.colors.push("black");
alert(instance1.colors);//1,2,3,black
var instance2 = new SubType();
alert(instance2.colors);//1,2,3,black
```

